//
//  VizScenegraph.swift
//  Glance
//
//  Created by Marc Prud'hommeaux on 5/27/21.
//  Copyright Â© 2021 io.glimpse. All rights reserved.
//


/// The scenegraph model.
///
/// Generated by Curio
public enum GGSceneGraph : Equatable, Hashable, Codable {
    case markCase(Mark)

    public init(_ arg: Mark) {
        self = .markCase(arg)
    }

    public func encode(to encoder: Encoder) throws -> () {
        switch self {
        case .markCase(let x): try x.encode(to: encoder)
        }
    }

    public init(from decoder: Decoder) throws {
        var errors: [Error] = []
        do { self = try .markCase(Mark(from: decoder)); return } catch { errors.append(error) }
        throw OneOfDecodingError(errors: errors)
    }

    public typealias Path = String

    /// Generated by Curio
    public enum LiteralButtOrCapOrRound : String, Equatable, Hashable, Codable, CaseIterable {
        case butt
        case cap
        case round
    }

    /// Generated by Curio
    public enum LiteralHorizontalOrVertical : String, Equatable, Hashable, Codable, CaseIterable {
        case horizontal
        case vertical
    }

    /// Generated by Curio
    public enum LiteralLeftOrCenterOrRight : String, Equatable, Hashable, Codable, CaseIterable {
        case left
        case center
        case right
    }

    /// Generated by Curio
    public enum LiteralMiterOrRoundOrBevel : String, Equatable, Hashable, Codable, CaseIterable {
        case miter
        case round
        case bevel
    }

    /// Generated by Curio
    public enum LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity : String, Equatable, Hashable, Codable, CaseIterable {
        case multiply
        case screen
        case overlay
        case darken
        case lighten
        case colorDodge = "color-dodge"
        case colorBurn = "color-burn"
        case hardLight = "hard-light"
        case softLight = "soft-light"
        case difference
        case exclusion
        case hue
        case saturation
        case color
        case luminosity
    }

    /// Generated by Curio
    public enum Mark : Equatable, Hashable, Codable {
        case markGroupCase(MarkGroup)
        case markArcCase(MarkArc)
        case markAreaCase(MarkArea)
        case markImageCase(MarkImage)
        case markLineCase(MarkLine)
        case markPathCase(MarkPath)
        case markRectCase(MarkRect)
        case markRuleCase(MarkRule)
        case markSymbolCase(MarkSymbol)
        case markTextCase(MarkText)
        case markTrailCase(MarkTrail)

        public init(_ arg: MarkGroup) {
            self = .markGroupCase(arg)
        }

        public init(_ arg: MarkArc) {
            self = .markArcCase(arg)
        }

        public init(_ arg: MarkArea) {
            self = .markAreaCase(arg)
        }

        public init(_ arg: MarkImage) {
            self = .markImageCase(arg)
        }

        public init(_ arg: MarkLine) {
            self = .markLineCase(arg)
        }

        public init(_ arg: MarkPath) {
            self = .markPathCase(arg)
        }

        public init(_ arg: MarkRect) {
            self = .markRectCase(arg)
        }

        public init(_ arg: MarkRule) {
            self = .markRuleCase(arg)
        }

        public init(_ arg: MarkSymbol) {
            self = .markSymbolCase(arg)
        }

        public init(_ arg: MarkText) {
            self = .markTextCase(arg)
        }

        public init(_ arg: MarkTrail) {
            self = .markTrailCase(arg)
        }

        public func encode(to encoder: Encoder) throws -> () {
            switch self {
            case .markGroupCase(let x): try x.encode(to: encoder)
            case .markArcCase(let x): try x.encode(to: encoder)
            case .markAreaCase(let x): try x.encode(to: encoder)
            case .markImageCase(let x): try x.encode(to: encoder)
            case .markLineCase(let x): try x.encode(to: encoder)
            case .markPathCase(let x): try x.encode(to: encoder)
            case .markRectCase(let x): try x.encode(to: encoder)
            case .markRuleCase(let x): try x.encode(to: encoder)
            case .markSymbolCase(let x): try x.encode(to: encoder)
            case .markTextCase(let x): try x.encode(to: encoder)
            case .markTrailCase(let x): try x.encode(to: encoder)
            }
        }

        public init(from decoder: Decoder) throws {
            var errors: [Error] = []
            do { self = try .markGroupCase(MarkGroup(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markArcCase(MarkArc(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markAreaCase(MarkArea(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markImageCase(MarkImage(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markLineCase(MarkLine(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markPathCase(MarkPath(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markRectCase(MarkRect(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markRuleCase(MarkRule(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markSymbolCase(MarkSymbol(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markTextCase(MarkText(from: decoder)); return } catch { errors.append(error) }
            do { self = try .markTrailCase(MarkTrail(from: decoder)); return } catch { errors.append(error) }
            throw OneOfDecodingError(errors: errors)
        }
    }

    public struct Color : Equatable, Hashable, Codable, RawCodable {
        public var rawValue: OneOf<String>.Or<String>.Or<String>.Or<String>.Or<String>

        public init(rawValue: OneOf<String>.Or<String>.Or<String>.Or<String>.Or<String>) {
            self.rawValue = rawValue
        }

        public init(_ rawValue: OneOf<String>.Or<String>.Or<String>.Or<String>.Or<String>) {
            self.rawValue = rawValue
        }
    }

    /// Generated by Curio
    public struct GradientStop : Equatable, Hashable, Codable, KeyedCodable {
        public var offset: Double
        public var color: Color
        public static let codingKeyPaths = (\Self.offset as KeyPath, \Self.color as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.offset as KeyPath : CodingKeys.offset, \Self.color as KeyPath : CodingKeys.color]

        public init(offset: Double, color: Color) {
            self.offset = offset
            self.color = color
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.offset = try values.decode(Double.self, forKey: .offset)
            self.color = try values.decode(Color.self, forKey: .color)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case offset
            case color
            public var keyDescription: String? {
                switch self {
                case .offset: return nil
                case .color: return nil
                 }
            }

            public typealias CodingOwner = GradientStop
        }
    }

    /// Generated by Curio
    public struct ItemArc : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var startAngle: Double?
        public var endAngle: Double?
        public var padAngle: Double?
        public var innerRadius: Double?
        public var outerRadius: Double?
        public var cornerRadius: Double?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.startAngle as KeyPath, \Self.endAngle as KeyPath, \Self.padAngle as KeyPath, \Self.innerRadius as KeyPath, \Self.outerRadius as KeyPath, \Self.cornerRadius as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.startAngle as KeyPath : CodingKeys.startAngle, \Self.endAngle as KeyPath : CodingKeys.endAngle, \Self.padAngle as KeyPath : CodingKeys.padAngle, \Self.innerRadius as KeyPath : CodingKeys.innerRadius, \Self.outerRadius as KeyPath : CodingKeys.outerRadius, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, startAngle: Double? = nil, endAngle: Double? = nil, padAngle: Double? = nil, innerRadius: Double? = nil, outerRadius: Double? = nil, cornerRadius: Double? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.startAngle = startAngle
            self.endAngle = endAngle
            self.padAngle = padAngle
            self.innerRadius = innerRadius
            self.outerRadius = outerRadius
            self.cornerRadius = cornerRadius
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.startAngle = try values.decodeOptional(Double.self, forKey: .startAngle)
            self.endAngle = try values.decodeOptional(Double.self, forKey: .endAngle)
            self.padAngle = try values.decodeOptional(Double.self, forKey: .padAngle)
            self.innerRadius = try values.decodeOptional(Double.self, forKey: .innerRadius)
            self.outerRadius = try values.decodeOptional(Double.self, forKey: .outerRadius)
            self.cornerRadius = try values.decodeOptional(Double.self, forKey: .cornerRadius)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case startAngle
            case endAngle
            case padAngle
            case innerRadius
            case outerRadius
            case cornerRadius
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .startAngle: return nil
                case .endAngle: return nil
                case .padAngle: return nil
                case .innerRadius: return nil
                case .outerRadius: return nil
                case .cornerRadius: return nil
                 }
            }

            public typealias CodingOwner = ItemArc
        }
    }

    /// Generated by Curio
    public struct ItemArea : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var defined: Bool?
        public var interpolate: LiteralBasisOrCardinalOrCatmullRomOrLinearOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore?
        public var tension: Double?
        public var orient: LiteralHorizontalOrVertical?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.defined as KeyPath, \Self.interpolate as KeyPath, \Self.tension as KeyPath, \Self.orient as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.defined as KeyPath : CodingKeys.defined, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.tension as KeyPath : CodingKeys.tension, \Self.orient as KeyPath : CodingKeys.orient]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, defined: Bool? = nil, interpolate: LiteralBasisOrCardinalOrCatmullRomOrLinearOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore? = nil, tension: Double? = nil, orient: LiteralHorizontalOrVertical? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.defined = defined
            self.interpolate = interpolate
            self.tension = tension
            self.orient = orient
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.defined = try values.decodeOptional(Bool.self, forKey: .defined)
            self.interpolate = try values.decodeOptional(LiteralBasisOrCardinalOrCatmullRomOrLinearOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore.self, forKey: .interpolate)
            self.tension = try values.decodeOptional(Double.self, forKey: .tension)
            self.orient = try values.decodeOptional(LiteralHorizontalOrVertical.self, forKey: .orient)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case defined
            case interpolate
            case tension
            case orient
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .defined: return nil
                case .interpolate: return nil
                case .tension: return nil
                case .orient: return nil
                 }
            }

            public typealias CodingOwner = ItemArea
        }

        /// Generated by Curio
        public enum LiteralBasisOrCardinalOrCatmullRomOrLinearOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore : String, Equatable, Hashable, Codable, CaseIterable {
            case basis
            case cardinal
            case catmullRom = "catmull-rom"
            case linear
            case monotone
            case natural
            case step
            case stepAfter = "step-after"
            case stepBefore = "step-before"
        }
    }

    /// Generated by Curio
    public struct ItemGroup : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var clip: Bool?
        public var cornerRadius: Double?
        public var cornerRadiusTopLeft: Double?
        public var cornerRadiusTopRight: Double?
        public var cornerRadiusBottomRight: Double?
        public var cornerRadiusBottomLeft: Double?
        public var items: [Mark]?
        public var strokeForeground: Bool?
        public var strokeOffset: Double?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.clip as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath, \Self.items as KeyPath, \Self.strokeForeground as KeyPath, \Self.strokeOffset as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.clip as KeyPath : CodingKeys.clip, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft, \Self.items as KeyPath : CodingKeys.items, \Self.strokeForeground as KeyPath : CodingKeys.strokeForeground, \Self.strokeOffset as KeyPath : CodingKeys.strokeOffset]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, clip: Bool? = nil, cornerRadius: Double? = nil, cornerRadiusTopLeft: Double? = nil, cornerRadiusTopRight: Double? = nil, cornerRadiusBottomRight: Double? = nil, cornerRadiusBottomLeft: Double? = nil, items: [Mark]? = nil, strokeForeground: Bool? = nil, strokeOffset: Double? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.clip = clip
            self.cornerRadius = cornerRadius
            self.cornerRadiusTopLeft = cornerRadiusTopLeft
            self.cornerRadiusTopRight = cornerRadiusTopRight
            self.cornerRadiusBottomRight = cornerRadiusBottomRight
            self.cornerRadiusBottomLeft = cornerRadiusBottomLeft
            self.items = items
            self.strokeForeground = strokeForeground
            self.strokeOffset = strokeOffset
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.clip = try values.decodeOptional(Bool.self, forKey: .clip)
            self.cornerRadius = try values.decodeOptional(Double.self, forKey: .cornerRadius)
            self.cornerRadiusTopLeft = try values.decodeOptional(Double.self, forKey: .cornerRadiusTopLeft)
            self.cornerRadiusTopRight = try values.decodeOptional(Double.self, forKey: .cornerRadiusTopRight)
            self.cornerRadiusBottomRight = try values.decodeOptional(Double.self, forKey: .cornerRadiusBottomRight)
            self.cornerRadiusBottomLeft = try values.decodeOptional(Double.self, forKey: .cornerRadiusBottomLeft)
            self.items = try values.decodeOptional([Mark].self, forKey: .items)
            self.strokeForeground = try values.decodeOptional(Bool.self, forKey: .strokeForeground)
            self.strokeOffset = try values.decodeOptional(Double.self, forKey: .strokeOffset)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case clip
            case cornerRadius
            case cornerRadiusTopLeft
            case cornerRadiusTopRight
            case cornerRadiusBottomRight
            case cornerRadiusBottomLeft
            case items
            case strokeForeground
            case strokeOffset
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .clip: return nil
                case .cornerRadius: return nil
                case .cornerRadiusTopLeft: return nil
                case .cornerRadiusTopRight: return nil
                case .cornerRadiusBottomRight: return nil
                case .cornerRadiusBottomLeft: return nil
                case .items: return nil
                case .strokeForeground: return nil
                case .strokeOffset: return nil
                 }
            }

            public typealias CodingOwner = ItemGroup
        }
    }

    /// Generated by Curio
    public struct ItemImage : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var url: String?
        public var aspect: Bool?
        public var smooth: Bool?
        public var align: LiteralLeftOrCenterOrRight?
        public var baseline: LiteralTopOrMiddleOrBottom?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.url as KeyPath, \Self.aspect as KeyPath, \Self.smooth as KeyPath, \Self.align as KeyPath, \Self.baseline as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.url as KeyPath : CodingKeys.url, \Self.aspect as KeyPath : CodingKeys.aspect, \Self.smooth as KeyPath : CodingKeys.smooth, \Self.align as KeyPath : CodingKeys.align, \Self.baseline as KeyPath : CodingKeys.baseline]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, url: String? = nil, aspect: Bool? = nil, smooth: Bool? = nil, align: LiteralLeftOrCenterOrRight? = nil, baseline: LiteralTopOrMiddleOrBottom? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.url = url
            self.aspect = aspect
            self.smooth = smooth
            self.align = align
            self.baseline = baseline
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.url = try values.decodeOptional(String.self, forKey: .url)
            self.aspect = try values.decodeOptional(Bool.self, forKey: .aspect)
            self.smooth = try values.decodeOptional(Bool.self, forKey: .smooth)
            self.align = try values.decodeOptional(LiteralLeftOrCenterOrRight.self, forKey: .align)
            self.baseline = try values.decodeOptional(LiteralTopOrMiddleOrBottom.self, forKey: .baseline)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case url
            case aspect
            case smooth
            case align
            case baseline
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .url: return nil
                case .aspect: return nil
                case .smooth: return nil
                case .align: return nil
                case .baseline: return nil
                 }
            }

            public typealias CodingOwner = ItemImage
        }

        /// Generated by Curio
        public enum LiteralTopOrMiddleOrBottom : String, Equatable, Hashable, Codable, CaseIterable {
            case top
            case middle
            case bottom
        }
    }

    /// Generated by Curio
    public struct ItemLine : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var defined: Bool?
        public var interpolate: LiteralBasisOrBasisClosedOrBasisOpenOrBundleOrCardinalOrCardinalClosedOrCardinalOpenOrCatmullRomOrCatmullRomClosedOrCatmullRomOpenOrLinearOrLinearClosedOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore?
        public var tension: Double?
        public var orient: LiteralHorizontalOrVertical?
        public var size: Double?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.defined as KeyPath, \Self.interpolate as KeyPath, \Self.tension as KeyPath, \Self.orient as KeyPath, \Self.size as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.defined as KeyPath : CodingKeys.defined, \Self.interpolate as KeyPath : CodingKeys.interpolate, \Self.tension as KeyPath : CodingKeys.tension, \Self.orient as KeyPath : CodingKeys.orient, \Self.size as KeyPath : CodingKeys.size]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, defined: Bool? = nil, interpolate: LiteralBasisOrBasisClosedOrBasisOpenOrBundleOrCardinalOrCardinalClosedOrCardinalOpenOrCatmullRomOrCatmullRomClosedOrCatmullRomOpenOrLinearOrLinearClosedOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore? = nil, tension: Double? = nil, orient: LiteralHorizontalOrVertical? = nil, size: Double? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.defined = defined
            self.interpolate = interpolate
            self.tension = tension
            self.orient = orient
            self.size = size
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.defined = try values.decodeOptional(Bool.self, forKey: .defined)
            self.interpolate = try values.decodeOptional(LiteralBasisOrBasisClosedOrBasisOpenOrBundleOrCardinalOrCardinalClosedOrCardinalOpenOrCatmullRomOrCatmullRomClosedOrCatmullRomOpenOrLinearOrLinearClosedOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore.self, forKey: .interpolate)
            self.tension = try values.decodeOptional(Double.self, forKey: .tension)
            self.orient = try values.decodeOptional(LiteralHorizontalOrVertical.self, forKey: .orient)
            self.size = try values.decodeOptional(Double.self, forKey: .size)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case defined
            case interpolate
            case tension
            case orient
            case size
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .defined: return nil
                case .interpolate: return nil
                case .tension: return nil
                case .orient: return nil
                case .size: return nil
                 }
            }

            public typealias CodingOwner = ItemLine
        }

        /// Generated by Curio
        public enum LiteralBasisOrBasisClosedOrBasisOpenOrBundleOrCardinalOrCardinalClosedOrCardinalOpenOrCatmullRomOrCatmullRomClosedOrCatmullRomOpenOrLinearOrLinearClosedOrMonotoneOrNaturalOrStepOrStepAfterOrStepBefore : String, Equatable, Hashable, Codable, CaseIterable {
            case basis
            case basisClosed = "basis-closed"
            case basisOpen = "basis-open"
            case bundle
            case cardinal
            case cardinalClosed = "cardinal-closed"
            case cardinalOpen = "cardinal-open"
            case catmullRom = "catmull-rom"
            case catmullRomClosed = "catmull-rom-closed"
            case catmullRomOpen = "catmull-rom-open"
            case linear
            case linearClosed = "linear-closed"
            case monotone
            case natural
            case step
            case stepAfter = "step-after"
            case stepBefore = "step-before"
        }
    }

    /// Generated by Curio
    public struct ItemPath : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var angle: Double?
        public var path: Path?
        public var scaleX: Double?
        public var scaleY: Double?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.angle as KeyPath, \Self.path as KeyPath, \Self.scaleX as KeyPath, \Self.scaleY as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.angle as KeyPath : CodingKeys.angle, \Self.path as KeyPath : CodingKeys.path, \Self.scaleX as KeyPath : CodingKeys.scaleX, \Self.scaleY as KeyPath : CodingKeys.scaleY]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, angle: Double? = nil, path: Path? = nil, scaleX: Double? = nil, scaleY: Double? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.angle = angle
            self.path = path
            self.scaleX = scaleX
            self.scaleY = scaleY
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.angle = try values.decodeOptional(Double.self, forKey: .angle)
            self.path = try values.decodeOptional(Path.self, forKey: .path)
            self.scaleX = try values.decodeOptional(Double.self, forKey: .scaleX)
            self.scaleY = try values.decodeOptional(Double.self, forKey: .scaleY)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case angle
            case path
            case scaleX
            case scaleY
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .angle: return nil
                case .path: return nil
                case .scaleX: return nil
                case .scaleY: return nil
                 }
            }

            public typealias CodingOwner = ItemPath
        }
    }

    /// Generated by Curio
    public struct ItemRect : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var cornerRadius: Double?
        public var cornerRadiusTopLeft: Double?
        public var cornerRadiusTopRight: Double?
        public var cornerRadiusBottomRight: Double?
        public var cornerRadiusBottomLeft: Double?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.cornerRadius as KeyPath, \Self.cornerRadiusTopLeft as KeyPath, \Self.cornerRadiusTopRight as KeyPath, \Self.cornerRadiusBottomRight as KeyPath, \Self.cornerRadiusBottomLeft as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.cornerRadius as KeyPath : CodingKeys.cornerRadius, \Self.cornerRadiusTopLeft as KeyPath : CodingKeys.cornerRadiusTopLeft, \Self.cornerRadiusTopRight as KeyPath : CodingKeys.cornerRadiusTopRight, \Self.cornerRadiusBottomRight as KeyPath : CodingKeys.cornerRadiusBottomRight, \Self.cornerRadiusBottomLeft as KeyPath : CodingKeys.cornerRadiusBottomLeft]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, cornerRadius: Double? = nil, cornerRadiusTopLeft: Double? = nil, cornerRadiusTopRight: Double? = nil, cornerRadiusBottomRight: Double? = nil, cornerRadiusBottomLeft: Double? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.cornerRadius = cornerRadius
            self.cornerRadiusTopLeft = cornerRadiusTopLeft
            self.cornerRadiusTopRight = cornerRadiusTopRight
            self.cornerRadiusBottomRight = cornerRadiusBottomRight
            self.cornerRadiusBottomLeft = cornerRadiusBottomLeft
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.cornerRadius = try values.decodeOptional(Double.self, forKey: .cornerRadius)
            self.cornerRadiusTopLeft = try values.decodeOptional(Double.self, forKey: .cornerRadiusTopLeft)
            self.cornerRadiusTopRight = try values.decodeOptional(Double.self, forKey: .cornerRadiusTopRight)
            self.cornerRadiusBottomRight = try values.decodeOptional(Double.self, forKey: .cornerRadiusBottomRight)
            self.cornerRadiusBottomLeft = try values.decodeOptional(Double.self, forKey: .cornerRadiusBottomLeft)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case cornerRadius
            case cornerRadiusTopLeft
            case cornerRadiusTopRight
            case cornerRadiusBottomRight
            case cornerRadiusBottomLeft
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .cornerRadius: return nil
                case .cornerRadiusTopLeft: return nil
                case .cornerRadiusTopRight: return nil
                case .cornerRadiusBottomRight: return nil
                case .cornerRadiusBottomLeft: return nil
                 }
            }

            public typealias CodingOwner = ItemRect
        }
    }

    /// Generated by Curio
    public struct ItemRule : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var x2: Double?
        public var y2: Double?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.x2 as KeyPath, \Self.y2 as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y2 as KeyPath : CodingKeys.y2]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, x2: Double? = nil, y2: Double? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.x2 = x2
            self.y2 = y2
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.x2 = try values.decodeOptional(Double.self, forKey: .x2)
            self.y2 = try values.decodeOptional(Double.self, forKey: .y2)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case x2
            case y2
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .x2: return nil
                case .y2: return nil
                 }
            }

            public typealias CodingOwner = ItemRule
        }
    }

    /// Generated by Curio
    public struct ItemSymbol : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var angle: Double?
        public var size: Double?
        public var shape: String?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.angle as KeyPath, \Self.size as KeyPath, \Self.shape as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.angle as KeyPath : CodingKeys.angle, \Self.size as KeyPath : CodingKeys.size, \Self.shape as KeyPath : CodingKeys.shape]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, angle: Double? = nil, size: Double? = nil, shape: String? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.angle = angle
            self.size = size
            self.shape = shape
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.angle = try values.decodeOptional(Double.self, forKey: .angle)
            self.size = try values.decodeOptional(Double.self, forKey: .size)
            self.shape = try values.decodeOptional(String.self, forKey: .shape)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case angle
            case size
            case shape
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .angle: return nil
                case .size: return nil
                case .shape: return nil
                 }
            }

            public typealias CodingOwner = ItemSymbol
        }
    }

    /// Generated by Curio
    public struct ItemText : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var text: TextChoice?
        public var limit: Double?
        public var lineHeight: Double?
        public var dir: String?
        public var ellipsis: String?
        public var align: LiteralLeftOrCenterOrRight?
        public var baseline: LiteralAlphabeticOrTopOrMiddleOrBottomOrLineTopOrLineBottom?
        public var angle: Double?
        public var theta: Double?
        public var radius: Double?
        public var dx: Double?
        public var dy: Double?
        public var font: String?
        public var fontSize: Double?
        public var fontStyle: LiteralNormalOrItalicOrOblique?
        public var fontWeight: LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900?
        public var fontVariant: LiteralNormalOrSmallCaps?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.text as KeyPath, \Self.limit as KeyPath, \Self.lineHeight as KeyPath, \Self.dir as KeyPath, \Self.ellipsis as KeyPath, \Self.align as KeyPath, \Self.baseline as KeyPath, \Self.angle as KeyPath, \Self.theta as KeyPath, \Self.radius as KeyPath, \Self.dx as KeyPath, \Self.dy as KeyPath, \Self.font as KeyPath, \Self.fontSize as KeyPath, \Self.fontStyle as KeyPath, \Self.fontWeight as KeyPath, \Self.fontVariant as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.text as KeyPath : CodingKeys.text, \Self.limit as KeyPath : CodingKeys.limit, \Self.lineHeight as KeyPath : CodingKeys.lineHeight, \Self.dir as KeyPath : CodingKeys.dir, \Self.ellipsis as KeyPath : CodingKeys.ellipsis, \Self.align as KeyPath : CodingKeys.align, \Self.baseline as KeyPath : CodingKeys.baseline, \Self.angle as KeyPath : CodingKeys.angle, \Self.theta as KeyPath : CodingKeys.theta, \Self.radius as KeyPath : CodingKeys.radius, \Self.dx as KeyPath : CodingKeys.dx, \Self.dy as KeyPath : CodingKeys.dy, \Self.font as KeyPath : CodingKeys.font, \Self.fontSize as KeyPath : CodingKeys.fontSize, \Self.fontStyle as KeyPath : CodingKeys.fontStyle, \Self.fontWeight as KeyPath : CodingKeys.fontWeight, \Self.fontVariant as KeyPath : CodingKeys.fontVariant]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, text: TextChoice? = nil, limit: Double? = nil, lineHeight: Double? = nil, dir: String? = nil, ellipsis: String? = nil, align: LiteralLeftOrCenterOrRight? = nil, baseline: LiteralAlphabeticOrTopOrMiddleOrBottomOrLineTopOrLineBottom? = nil, angle: Double? = nil, theta: Double? = nil, radius: Double? = nil, dx: Double? = nil, dy: Double? = nil, font: String? = nil, fontSize: Double? = nil, fontStyle: LiteralNormalOrItalicOrOblique? = nil, fontWeight: LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900? = nil, fontVariant: LiteralNormalOrSmallCaps? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.text = text
            self.limit = limit
            self.lineHeight = lineHeight
            self.dir = dir
            self.ellipsis = ellipsis
            self.align = align
            self.baseline = baseline
            self.angle = angle
            self.theta = theta
            self.radius = radius
            self.dx = dx
            self.dy = dy
            self.font = font
            self.fontSize = fontSize
            self.fontStyle = fontStyle
            self.fontWeight = fontWeight
            self.fontVariant = fontVariant
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.text = try values.decodeOptional(TextChoice.self, forKey: .text)
            self.limit = try values.decodeOptional(Double.self, forKey: .limit)
            self.lineHeight = try values.decodeOptional(Double.self, forKey: .lineHeight)
            self.dir = try values.decodeOptional(String.self, forKey: .dir)
            self.ellipsis = try values.decodeOptional(String.self, forKey: .ellipsis)
            self.align = try values.decodeOptional(LiteralLeftOrCenterOrRight.self, forKey: .align)
            self.baseline = try values.decodeOptional(LiteralAlphabeticOrTopOrMiddleOrBottomOrLineTopOrLineBottom.self, forKey: .baseline)
            self.angle = try values.decodeOptional(Double.self, forKey: .angle)
            self.theta = try values.decodeOptional(Double.self, forKey: .theta)
            self.radius = try values.decodeOptional(Double.self, forKey: .radius)
            self.dx = try values.decodeOptional(Double.self, forKey: .dx)
            self.dy = try values.decodeOptional(Double.self, forKey: .dy)
            self.font = try values.decodeOptional(String.self, forKey: .font)
            self.fontSize = try values.decodeOptional(Double.self, forKey: .fontSize)
            self.fontStyle = try values.decodeOptional(LiteralNormalOrItalicOrOblique.self, forKey: .fontStyle)
            self.fontWeight = try values.decodeOptional(LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900.self, forKey: .fontWeight)
            self.fontVariant = try values.decodeOptional(LiteralNormalOrSmallCaps.self, forKey: .fontVariant)
        }

        /// Generated by Curio
        public typealias LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900 = OneOf<LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900String>.Or<LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900Double>
        /// Generated by Curio
        public enum LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900String : String, Equatable, Hashable, Codable, CaseIterable {
            case normal
            case bold
            case bolder
            case lighter
        }
        /// Generated by Curio
        public enum LiteralNormalOrBoldOrBolderOrLighterOr100Or200Or300Or400Or500Or600Or700Or800Or900Double : Double, Equatable, Hashable, Codable, CaseIterable {
            case n100_0 = 100.0
            case n200_0 = 200.0
            case n300_0 = 300.0
            case n400_0 = 400.0
            case n500_0 = 500.0
            case n600_0 = 600.0
            case n700_0 = 700.0
            case n800_0 = 800.0
            case n900_0 = 900.0
        }

        public typealias StrokeDashItem = Double

        /// Generated by Curio
        public typealias TextChoice = OneOrMany<String>

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case text
            case limit
            case lineHeight
            case dir
            case ellipsis
            case align
            case baseline
            case angle
            case theta
            case radius
            case dx
            case dy
            case font
            case fontSize
            case fontStyle
            case fontWeight
            case fontVariant
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .text: return nil
                case .limit: return nil
                case .lineHeight: return nil
                case .dir: return nil
                case .ellipsis: return nil
                case .align: return nil
                case .baseline: return nil
                case .angle: return nil
                case .theta: return nil
                case .radius: return nil
                case .dx: return nil
                case .dy: return nil
                case .font: return nil
                case .fontSize: return nil
                case .fontStyle: return nil
                case .fontWeight: return nil
                case .fontVariant: return nil
                 }
            }

            public typealias CodingOwner = ItemText
        }

        /// Generated by Curio
        public enum LiteralAlphabeticOrTopOrMiddleOrBottomOrLineTopOrLineBottom : String, Equatable, Hashable, Codable, CaseIterable {
            case alphabetic
            case top
            case middle
            case bottom
            case lineTop = "line-top"
            case lineBottom = "line-bottom"
        }

        /// Generated by Curio
        public enum LiteralNormalOrItalicOrOblique : String, Equatable, Hashable, Codable, CaseIterable {
            case normal
            case italic
            case oblique
        }

        /// Generated by Curio
        public enum LiteralNormalOrSmallCaps : String, Equatable, Hashable, Codable, CaseIterable {
            case normal
            case smallCaps = "small-caps"
        }
    }

    /// Generated by Curio
    public struct ItemTrail : Equatable, Hashable, Codable, KeyedCodable {
        public var x: Double?
        public var y: Double?
        public var width: Double?
        public var height: Double?
        public var blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity?
        public var opacity: Double?
        public var fill: Paint?
        public var fillOpacity: Double?
        public var stroke: Paint?
        public var strokeOpacity: Double?
        public var strokeWidth: Double?
        public var strokeCap: LiteralButtOrCapOrRound?
        public var strokeJoin: LiteralMiterOrRoundOrBevel?
        public var strokeMiterLimit: Double?
        public var strokeDash: [StrokeDashItem]?
        public var strokeDashOffset: Double?
        public var zindex: Double?
        public var cursor: String?
        public var href: String?
        public var tooltip: Tooltip?
        public var description: String?
        public var aria: Bool?
        public var ariaRole: String?
        public var ariaRoleDescription: String?
        public var defined: Bool?
        public var size: Double?
        public static let codingKeyPaths = (\Self.x as KeyPath, \Self.y as KeyPath, \Self.width as KeyPath, \Self.height as KeyPath, \Self.blend as KeyPath, \Self.opacity as KeyPath, \Self.fill as KeyPath, \Self.fillOpacity as KeyPath, \Self.stroke as KeyPath, \Self.strokeOpacity as KeyPath, \Self.strokeWidth as KeyPath, \Self.strokeCap as KeyPath, \Self.strokeJoin as KeyPath, \Self.strokeMiterLimit as KeyPath, \Self.strokeDash as KeyPath, \Self.strokeDashOffset as KeyPath, \Self.zindex as KeyPath, \Self.cursor as KeyPath, \Self.href as KeyPath, \Self.tooltip as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.ariaRole as KeyPath, \Self.ariaRoleDescription as KeyPath, \Self.defined as KeyPath, \Self.size as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.x as KeyPath : CodingKeys.x, \Self.y as KeyPath : CodingKeys.y, \Self.width as KeyPath : CodingKeys.width, \Self.height as KeyPath : CodingKeys.height, \Self.blend as KeyPath : CodingKeys.blend, \Self.opacity as KeyPath : CodingKeys.opacity, \Self.fill as KeyPath : CodingKeys.fill, \Self.fillOpacity as KeyPath : CodingKeys.fillOpacity, \Self.stroke as KeyPath : CodingKeys.stroke, \Self.strokeOpacity as KeyPath : CodingKeys.strokeOpacity, \Self.strokeWidth as KeyPath : CodingKeys.strokeWidth, \Self.strokeCap as KeyPath : CodingKeys.strokeCap, \Self.strokeJoin as KeyPath : CodingKeys.strokeJoin, \Self.strokeMiterLimit as KeyPath : CodingKeys.strokeMiterLimit, \Self.strokeDash as KeyPath : CodingKeys.strokeDash, \Self.strokeDashOffset as KeyPath : CodingKeys.strokeDashOffset, \Self.zindex as KeyPath : CodingKeys.zindex, \Self.cursor as KeyPath : CodingKeys.cursor, \Self.href as KeyPath : CodingKeys.href, \Self.tooltip as KeyPath : CodingKeys.tooltip, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.ariaRole as KeyPath : CodingKeys.ariaRole, \Self.ariaRoleDescription as KeyPath : CodingKeys.ariaRoleDescription, \Self.defined as KeyPath : CodingKeys.defined, \Self.size as KeyPath : CodingKeys.size]

        public init(x: Double? = nil, y: Double? = nil, width: Double? = nil, height: Double? = nil, blend: LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity? = nil, opacity: Double? = nil, fill: Paint? = nil, fillOpacity: Double? = nil, stroke: Paint? = nil, strokeOpacity: Double? = nil, strokeWidth: Double? = nil, strokeCap: LiteralButtOrCapOrRound? = nil, strokeJoin: LiteralMiterOrRoundOrBevel? = nil, strokeMiterLimit: Double? = nil, strokeDash: [StrokeDashItem]? = nil, strokeDashOffset: Double? = nil, zindex: Double? = nil, cursor: String? = nil, href: String? = nil, tooltip: Tooltip? = nil, description: String? = nil, aria: Bool? = nil, ariaRole: String? = nil, ariaRoleDescription: String? = nil, defined: Bool? = nil, size: Double? = nil) {
            self.x = x
            self.y = y
            self.width = width
            self.height = height
            self.blend = blend
            self.opacity = opacity
            self.fill = fill
            self.fillOpacity = fillOpacity
            self.stroke = stroke
            self.strokeOpacity = strokeOpacity
            self.strokeWidth = strokeWidth
            self.strokeCap = strokeCap
            self.strokeJoin = strokeJoin
            self.strokeMiterLimit = strokeMiterLimit
            self.strokeDash = strokeDash
            self.strokeDashOffset = strokeDashOffset
            self.zindex = zindex
            self.cursor = cursor
            self.href = href
            self.tooltip = tooltip
            self.description = description
            self.aria = aria
            self.ariaRole = ariaRole
            self.ariaRoleDescription = ariaRoleDescription
            self.defined = defined
            self.size = size
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.x = try values.decodeOptional(Double.self, forKey: .x)
            self.y = try values.decodeOptional(Double.self, forKey: .y)
            self.width = try values.decodeOptional(Double.self, forKey: .width)
            self.height = try values.decodeOptional(Double.self, forKey: .height)
            self.blend = try values.decodeOptional(LiteralMultiplyOrScreenOrOverlayOrDarkenOrLightenOrColorDodgeOrColorBurnOrHardLightOrSoftLightOrDifferenceOrExclusionOrHueOrSaturationOrColorOrLuminosity.self, forKey: .blend)
            self.opacity = try values.decodeOptional(Double.self, forKey: .opacity)
            self.fill = try values.decodeOptional(Paint.self, forKey: .fill)
            self.fillOpacity = try values.decodeOptional(Double.self, forKey: .fillOpacity)
            self.stroke = try values.decodeOptional(Paint.self, forKey: .stroke)
            self.strokeOpacity = try values.decodeOptional(Double.self, forKey: .strokeOpacity)
            self.strokeWidth = try values.decodeOptional(Double.self, forKey: .strokeWidth)
            self.strokeCap = try values.decodeOptional(LiteralButtOrCapOrRound.self, forKey: .strokeCap)
            self.strokeJoin = try values.decodeOptional(LiteralMiterOrRoundOrBevel.self, forKey: .strokeJoin)
            self.strokeMiterLimit = try values.decodeOptional(Double.self, forKey: .strokeMiterLimit)
            self.strokeDash = try values.decodeOptional([StrokeDashItem].self, forKey: .strokeDash)
            self.strokeDashOffset = try values.decodeOptional(Double.self, forKey: .strokeDashOffset)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
            self.cursor = try values.decodeOptional(String.self, forKey: .cursor)
            self.href = try values.decodeOptional(String.self, forKey: .href)
            self.tooltip = try values.decodeOptional(Tooltip.self, forKey: .tooltip)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.ariaRole = try values.decodeOptional(String.self, forKey: .ariaRole)
            self.ariaRoleDescription = try values.decodeOptional(String.self, forKey: .ariaRoleDescription)
            self.defined = try values.decodeOptional(Bool.self, forKey: .defined)
            self.size = try values.decodeOptional(Double.self, forKey: .size)
        }

        public typealias StrokeDashItem = Double

        public typealias Tooltip = Bric

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case x
            case y
            case width
            case height
            case blend
            case opacity
            case fill
            case fillOpacity
            case stroke
            case strokeOpacity
            case strokeWidth
            case strokeCap
            case strokeJoin
            case strokeMiterLimit
            case strokeDash
            case strokeDashOffset
            case zindex
            case cursor
            case href
            case tooltip
            case description
            case aria
            case ariaRole
            case ariaRoleDescription
            case defined
            case size
            public var keyDescription: String? {
                switch self {
                case .x: return nil
                case .y: return nil
                case .width: return nil
                case .height: return nil
                case .blend: return nil
                case .opacity: return nil
                case .fill: return nil
                case .fillOpacity: return nil
                case .stroke: return nil
                case .strokeOpacity: return nil
                case .strokeWidth: return nil
                case .strokeCap: return nil
                case .strokeJoin: return nil
                case .strokeMiterLimit: return nil
                case .strokeDash: return nil
                case .strokeDashOffset: return nil
                case .zindex: return nil
                case .cursor: return nil
                case .href: return nil
                case .tooltip: return nil
                case .description: return nil
                case .aria: return nil
                case .ariaRole: return nil
                case .ariaRoleDescription: return nil
                case .defined: return nil
                case .size: return nil
                 }
            }

            public typealias CodingOwner = ItemTrail
        }
    }

    /// Generated by Curio
    public struct LinearGradient : Equatable, Hashable, Codable, KeyedCodable {
        public var gradient: LiteralLinear
        public var id: String?
        public var x1: Double?
        public var y1: Double?
        public var x2: Double?
        public var y2: Double?
        public var stops: [GradientStop]
        public static let codingKeyPaths = (\Self.gradient as KeyPath, \Self.id as KeyPath, \Self.x1 as KeyPath, \Self.y1 as KeyPath, \Self.x2 as KeyPath, \Self.y2 as KeyPath, \Self.stops as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.gradient as KeyPath : CodingKeys.gradient, \Self.id as KeyPath : CodingKeys.id, \Self.x1 as KeyPath : CodingKeys.x1, \Self.y1 as KeyPath : CodingKeys.y1, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y2 as KeyPath : CodingKeys.y2, \Self.stops as KeyPath : CodingKeys.stops]

        public init(gradient: LiteralLinear = .linear, id: String? = nil, x1: Double? = nil, y1: Double? = nil, x2: Double? = nil, y2: Double? = nil, stops: [GradientStop] = []) {
            self.gradient = gradient
            self.id = id
            self.x1 = x1
            self.y1 = y1
            self.x2 = x2
            self.y2 = y2
            self.stops = stops
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.gradient = try values.decode(LiteralLinear.self, forKey: .gradient)
            self.id = try values.decodeOptional(String.self, forKey: .id)
            self.x1 = try values.decodeOptional(Double.self, forKey: .x1)
            self.y1 = try values.decodeOptional(Double.self, forKey: .y1)
            self.x2 = try values.decodeOptional(Double.self, forKey: .x2)
            self.y2 = try values.decodeOptional(Double.self, forKey: .y2)
            self.stops = try values.decode([GradientStop].self, forKey: .stops)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case gradient
            case id
            case x1
            case y1
            case x2
            case y2
            case stops
            public var keyDescription: String? {
                switch self {
                case .gradient: return nil
                case .id: return nil
                case .x1: return nil
                case .y1: return nil
                case .x2: return nil
                case .y2: return nil
                case .stops: return nil
                 }
            }

            public typealias CodingOwner = LinearGradient
        }

        /// Generated by Curio
        public enum LiteralLinear : String, Equatable, Hashable, Codable, CaseIterable {
            case linear
        }
    }

    /// Generated by Curio
    public struct MarkArc : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralArc
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemArc]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralArc = .arc, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemArc]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralArc.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemArc].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkArc
        }

        /// Generated by Curio
        public enum LiteralArc : String, Equatable, Hashable, Codable, CaseIterable {
            case arc
        }
    }

    /// Generated by Curio
    public struct MarkArea : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralArea
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemArea]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralArea = .area, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemArea]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralArea.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemArea].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkArea
        }

        /// Generated by Curio
        public enum LiteralArea : String, Equatable, Hashable, Codable, CaseIterable {
            case area
        }
    }

    /// Generated by Curio
    public struct MarkGroup : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralGroup
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemGroup]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralGroup = .group, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemGroup]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralGroup.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemGroup].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkGroup
        }

        /// Generated by Curio
        public enum LiteralGroup : String, Equatable, Hashable, Codable, CaseIterable {
            case group
        }
    }

    /// Generated by Curio
    public struct MarkImage : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralImage
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemImage]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralImage = .image, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemImage]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralImage.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemImage].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkImage
        }

        /// Generated by Curio
        public enum LiteralImage : String, Equatable, Hashable, Codable, CaseIterable {
            case image
        }
    }

    /// Generated by Curio
    public struct MarkLine : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralLine
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemLine]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralLine = .line, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemLine]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralLine.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemLine].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkLine
        }

        /// Generated by Curio
        public enum LiteralLine : String, Equatable, Hashable, Codable, CaseIterable {
            case line
        }
    }

    /// Generated by Curio
    public struct MarkPath : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralPath
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemPath]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralPath = .path, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemPath]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralPath.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemPath].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkPath
        }

        /// Generated by Curio
        public enum LiteralPath : String, Equatable, Hashable, Codable, CaseIterable {
            case path
        }
    }

    /// Generated by Curio
    public struct MarkRect : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralRect
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemRect]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralRect = .rect, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemRect]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralRect.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemRect].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkRect
        }

        /// Generated by Curio
        public enum LiteralRect : String, Equatable, Hashable, Codable, CaseIterable {
            case rect
        }
    }

    /// Generated by Curio
    public struct MarkRule : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralRule
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemRule]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralRule = .rule, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemRule]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralRule.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemRule].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkRule
        }

        /// Generated by Curio
        public enum LiteralRule : String, Equatable, Hashable, Codable, CaseIterable {
            case rule
        }
    }

    /// Generated by Curio
    public struct MarkSymbol : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralSymbol
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemSymbol]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralSymbol = .symbol, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemSymbol]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralSymbol.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemSymbol].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkSymbol
        }

        /// Generated by Curio
        public enum LiteralSymbol : String, Equatable, Hashable, Codable, CaseIterable {
            case symbol
        }
    }

    /// Generated by Curio
    public struct MarkText : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralText
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemText]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralText = .text, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemText]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralText.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemText].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkText
        }

        /// Generated by Curio
        public enum LiteralText : String, Equatable, Hashable, Codable, CaseIterable {
            case text
        }
    }

    /// Generated by Curio
    public struct MarkTrail : Equatable, Hashable, Codable, KeyedCodable {
        public var marktype: LiteralTrail
        public var name: String?
        public var role: String?
        public var description: String?
        public var aria: Bool?
        public var interactive: Bool?
        public var items: [ItemTrail]?
        public var zindex: Double?
        public static let codingKeyPaths = (\Self.marktype as KeyPath, \Self.name as KeyPath, \Self.role as KeyPath, \Self.description as KeyPath, \Self.aria as KeyPath, \Self.interactive as KeyPath, \Self.items as KeyPath, \Self.zindex as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.marktype as KeyPath : CodingKeys.marktype, \Self.name as KeyPath : CodingKeys.name, \Self.role as KeyPath : CodingKeys.role, \Self.description as KeyPath : CodingKeys.description, \Self.aria as KeyPath : CodingKeys.aria, \Self.interactive as KeyPath : CodingKeys.interactive, \Self.items as KeyPath : CodingKeys.items, \Self.zindex as KeyPath : CodingKeys.zindex]

        public init(marktype: LiteralTrail = .trail, name: String? = nil, role: String? = nil, description: String? = nil, aria: Bool? = nil, interactive: Bool? = nil, items: [ItemTrail]? = nil, zindex: Double? = nil) {
            self.marktype = marktype
            self.name = name
            self.role = role
            self.description = description
            self.aria = aria
            self.interactive = interactive
            self.items = items
            self.zindex = zindex
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.marktype = try values.decode(LiteralTrail.self, forKey: .marktype)
            self.name = try values.decodeOptional(String.self, forKey: .name)
            self.role = try values.decodeOptional(String.self, forKey: .role)
            self.description = try values.decodeOptional(String.self, forKey: .description)
            self.aria = try values.decodeOptional(Bool.self, forKey: .aria)
            self.interactive = try values.decodeOptional(Bool.self, forKey: .interactive)
            self.items = try values.decodeOptional([ItemTrail].self, forKey: .items)
            self.zindex = try values.decodeOptional(Double.self, forKey: .zindex)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case marktype
            case name
            case role
            case description
            case aria
            case interactive
            case items
            case zindex
            public var keyDescription: String? {
                switch self {
                case .marktype: return nil
                case .name: return nil
                case .role: return nil
                case .description: return nil
                case .aria: return nil
                case .interactive: return nil
                case .items: return nil
                case .zindex: return nil
                 }
            }

            public typealias CodingOwner = MarkTrail
        }

        /// Generated by Curio
        public enum LiteralTrail : String, Equatable, Hashable, Codable, CaseIterable {
            case trail
        }
    }

    public struct Paint : Equatable, Hashable, Codable, RawCodable {
        public var rawValue: OneOf<Color>.Or<LinearGradient>.Or<RadialGradient>

        public init(rawValue: OneOf<Color>.Or<LinearGradient>.Or<RadialGradient>) {
            self.rawValue = rawValue
        }

        public init(_ rawValue: OneOf<Color>.Or<LinearGradient>.Or<RadialGradient>) {
            self.rawValue = rawValue
        }
    }

    /// Generated by Curio
    public struct RadialGradient : Equatable, Hashable, Codable, KeyedCodable {
        public var gradient: LiteralRadial
        public var id: String?
        public var x1: Double?
        public var y1: Double?
        public var r1: Double?
        public var x2: Double?
        public var y2: Double?
        public var r2: Double?
        public var stops: [GradientStop]
        public static let codingKeyPaths = (\Self.gradient as KeyPath, \Self.id as KeyPath, \Self.x1 as KeyPath, \Self.y1 as KeyPath, \Self.r1 as KeyPath, \Self.x2 as KeyPath, \Self.y2 as KeyPath, \Self.r2 as KeyPath, \Self.stops as KeyPath)
        public static let codableKeys: Dictionary<PartialKeyPath<Self>, CodingKeys> = [\Self.gradient as KeyPath : CodingKeys.gradient, \Self.id as KeyPath : CodingKeys.id, \Self.x1 as KeyPath : CodingKeys.x1, \Self.y1 as KeyPath : CodingKeys.y1, \Self.r1 as KeyPath : CodingKeys.r1, \Self.x2 as KeyPath : CodingKeys.x2, \Self.y2 as KeyPath : CodingKeys.y2, \Self.r2 as KeyPath : CodingKeys.r2, \Self.stops as KeyPath : CodingKeys.stops]

        public init(gradient: LiteralRadial = .radial, id: String? = nil, x1: Double? = nil, y1: Double? = nil, r1: Double? = nil, x2: Double? = nil, y2: Double? = nil, r2: Double? = nil, stops: [GradientStop] = []) {
            self.gradient = gradient
            self.id = id
            self.x1 = x1
            self.y1 = y1
            self.r1 = r1
            self.x2 = x2
            self.y2 = y2
            self.r2 = r2
            self.stops = stops
        }

        public init(from decoder: Decoder) throws {
            try decoder.forbidAdditionalProperties(notContainedIn: CodingKeys.allCases)
            let values = try decoder.container(keyedBy: CodingKeys.self)
            self.gradient = try values.decode(LiteralRadial.self, forKey: .gradient)
            self.id = try values.decodeOptional(String.self, forKey: .id)
            self.x1 = try values.decodeOptional(Double.self, forKey: .x1)
            self.y1 = try values.decodeOptional(Double.self, forKey: .y1)
            self.r1 = try values.decodeOptional(Double.self, forKey: .r1)
            self.x2 = try values.decodeOptional(Double.self, forKey: .x2)
            self.y2 = try values.decodeOptional(Double.self, forKey: .y2)
            self.r2 = try values.decodeOptional(Double.self, forKey: .r2)
            self.stops = try values.decode([GradientStop].self, forKey: .stops)
        }

        public enum CodingKeys : String, CodingKey, Hashable, Codable, CaseIterable {
            case gradient
            case id
            case x1
            case y1
            case r1
            case x2
            case y2
            case r2
            case stops
            public var keyDescription: String? {
                switch self {
                case .gradient: return nil
                case .id: return nil
                case .x1: return nil
                case .y1: return nil
                case .r1: return nil
                case .x2: return nil
                case .y2: return nil
                case .r2: return nil
                case .stops: return nil
                 }
            }

            public typealias CodingOwner = RadialGradient
        }

        /// Generated by Curio
        public enum LiteralRadial : String, Equatable, Hashable, Codable, CaseIterable {
            case radial
        }
    }
}

